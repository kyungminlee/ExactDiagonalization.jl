var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [ExactDiagonalization]","category":"page"},{"location":"api/#ExactDiagonalization.AbstractHilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.AbstractHilbertSpaceRepresentation","text":"AbstractHilbertSpaceRepresentation{S}\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.AbstractOperator","page":"API","title":"ExactDiagonalization.AbstractOperator","text":"AbstractOperator{S<:Number}\n\nRepresent an abstract operator in Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.AbstractOperatorRepresentation","page":"API","title":"ExactDiagonalization.AbstractOperatorRepresentation","text":"AbstractOperatorRepresentation{S}\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.FrozenSortedArrayIndex","page":"API","title":"ExactDiagonalization.FrozenSortedArrayIndex","text":"FrozenSortedArrayIndex(items)\n\nAn immutable sorted array, with index lookup using binary search.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpace","page":"API","title":"ExactDiagonalization.HilbertSpace","text":"HilbertSpace{QN}\n\nAbstract Hilbert space with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site])\nHilbertSpace{Tuple{Int64}}(Site{Tuple{Int64}}[Site{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))]), Site{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))])], [1, 1], [0, 1, 2])\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.HilbertSpaceRepresentation","text":"HilbertSpaceRepresentation{HS, BR, DictType}\n\nFields\n\nhilbert_space :: HS\nbasis_list    :: Vector{BR}\nbasis_lookup  :: DictType\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpaceSector","page":"API","title":"ExactDiagonalization.HilbertSpaceSector","text":"HilbertSpaceSector{QN}\n\nHilbert space sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.IntegerModulo","page":"API","title":"ExactDiagonalization.IntegerModulo","text":"IntegerModulo{N}\n\nImplement Zₙ.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.NullOperator","page":"API","title":"ExactDiagonalization.NullOperator","text":"NullOperator\n\nA null operator, i.e. 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.OperatorRepresentation","page":"API","title":"ExactDiagonalization.OperatorRepresentation","text":"OperatorRepresentation{HSR, S, O}\n\nOperator representation of given operator of type O.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.PureOperator","page":"API","title":"ExactDiagonalization.PureOperator","text":"PureOperator{Scalar, BR}\n\nRepresents an operator α (P₁  P₂    Pₙ) where Pᵢ is either identity (when bitmask is set to zero), or projection rᵢcᵢ (when bitmask is set to one).\n\nSee also: pure_operator\n\nFields\n\nbitmask   :: BR\nbitrow    :: BR\nbitcol    :: BR\namplitude :: Scalar\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.ReducedHilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.ReducedHilbertSpaceRepresentation","text":"ReducedHilbertSpaceRepresentation{HSR, BR, C}\n\nRepresentation of the symmetry-reduced hilbert space. Currently only supports Translation group (i.e. Abelian group). ```\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.ReducedOperatorRepresentation","page":"API","title":"ExactDiagonalization.ReducedOperatorRepresentation","text":"ReducedOperatorRepresentation{RHSR, O, S, BR}\n\nRepresentation of an operator of type O in the symmetry-reduced hilbert space representation of type RHSR.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.Site","page":"API","title":"ExactDiagonalization.Site","text":"Site{QN}\n\nA site with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> site = Site([State(\"Up\", 1), State(\"Dn\", -1)]);\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.SparseState","page":"API","title":"ExactDiagonalization.SparseState","text":"struct SparseState{Scalar<:Number, BR}\n\nRepresents a vector in unrestricted Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.SparseState-Union{Tuple{S}, Tuple{DT}, Tuple{BR}, Tuple{HS}, Tuple{HilbertSpaceRepresentation{HS,BR,DT},AbstractArray{S,1}}, Tuple{HilbertSpaceRepresentation{HS,BR,DT},AbstractArray{S,1},Real}} where S<:Number where DT where BR where HS","page":"API","title":"ExactDiagonalization.SparseState","text":"SparseState(hsrep, state_rep, tol=√eps(Float64))\n\nMake a SparseState from a representation\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.State","page":"API","title":"ExactDiagonalization.State","text":"State{QN}\n\nState with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> up = State(\"Up\", 1)\nState{Tuple{Int64}}(\"Up\", (1,))\n\njulia> State(\"Dn\", (-1, 1))\nState{Tuple{Int64,Int64}}(\"Dn\", (-1, 1))\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.SumOperator","page":"API","title":"ExactDiagonalization.SumOperator","text":"SumOperator{Scalar, BR}\n\nRepresents a sum of pure operators.\n\nFields\n\nterms::Vector{PureOperator{Scalar,BR}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.valtype-Tuple{Type{var\"#s23\"} where var\"#s23\"<:HilbertSpace}","page":"API","title":"Base.valtype","text":"valtype(::Type{HilbertSpace{QN}})\n\nReturns the valtype (scalar type) of the given hilbert space type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.valtype-Union{Tuple{Type{HilbertSpaceSector{HS,QN}}}, Tuple{QN}, Tuple{HS}} where QN where HS","page":"API","title":"Base.valtype","text":"valtype(arg::Type{HilbertSpaceSector{HS, QN}})\n\nReturns the valtype (scalar type) of the given hilbert space sector type. For HilbertSpaceSector{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.valtype-Union{Tuple{Type{var\"#s23\"} where var\"#s23\"<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"Base.valtype","text":"valtype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the valtype (scalar type) of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{BR}, Tuple{S2}, Tuple{S1}, Tuple{SparseState{S1,BR},NullOperator,SparseState{S2,BR}}} where BR where S2 where S1","page":"API","title":"ExactDiagonalization.apply!","text":"apply!(out, nullop, psi)\n\nApply operator to psi and add it to out.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_parallel!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_parallel!","text":"apply_parallel!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_parallel!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_parallel!","text":"apply_parallel!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_serial!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_serial!","text":"apply_serial!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_serial!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_serial!","text":"apply_serial!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.basespace-Tuple{HilbertSpace}","page":"API","title":"ExactDiagonalization.basespace","text":"basespace(hs)\n\nGet the base space of the HilbertSpace hs, which is itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.basespace-Union{Tuple{HilbertSpaceSector{HS,QN}}, Tuple{QN}, Tuple{HS}} where QN where HS","page":"API","title":"ExactDiagonalization.basespace","text":"basespace(hss)\n\nGet the base space of the HilbertSpaceSector, which is its parent HilbertSpace (with no quantum number restriction).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.bitwidth-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.bitwidth","text":"bitwidth(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall bitwidth with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.bitwidth-Tuple{HilbertSpace}","page":"API","title":"ExactDiagonalization.bitwidth","text":"Total number of bits\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)])\nSite{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))])\n\njulia> hs = HilbertSpace([spin_site, spin_site, spin_site,])\nHilbertSpace{Tuple{Int64}}(Site{Tuple{Int64}}[Site{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))]), Site{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))]), Site{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))])], [1, 1, 1], [0, 1, 2, 3])\n\njulia> bitwidth(hs)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.bitwidth-Tuple{Site}","page":"API","title":"ExactDiagonalization.bitwidth","text":"bitwidth(site)\n\nNumber of bits necessary to represent the states of the given site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.compress","text":"compress(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall compress with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Union{Tuple{BR}, Tuple{AbstractArray{var\"#s14\",1} where var\"#s14\"<:Integer,AbstractArray{var\"#s13\",1} where var\"#s13\"<:Integer,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.compress","text":"compress(bitwidths, data, BR)\n\nCompress data array into a binary integer of type BR.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},CartesianIndex}, Tuple{HilbertSpace{QN},CartesianIndex,Type{BR}}} where BR<:Unsigned where QN","page":"API","title":"ExactDiagonalization.compress","text":"compress(hs, indexarray::CartesianIndex, binary_type=UInt)\n\nConvert a cartesian index (a of state) to its binary representation\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\njulia> compress(hs, CartesianIndex(2,2))\n0x0000000000000003\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Union{Tuple{BR}, Tuple{Site,Integer}, Tuple{Site,Integer,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.compress","text":"compress(site, state_index, binary_type=UInt) -> binary_type\n\nGet binary representation of the state specified by state_index. Check bounds 1 <= state_index <= dimension(site), and returns binary representation of state_index-1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.extract-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.extract","text":"extract(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall extract with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.extract-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},BR}} where BR<:Unsigned where QN","page":"API","title":"ExactDiagonalization.extract","text":"Convert binary representation to an array of indices (of states)\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\njulia> extract(hs, 0x03)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_bitmask-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.get_bitmask","text":"get_bitmask(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_bitmask with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_column_iterator-Union{Tuple{BR}, Tuple{NullOperator,BR}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_column_iterator","text":"get_column_iterator(op, bcol)\n\nReturns an iterator over the elements of the column corresponding to bit representation bc.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_column_iterator-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_column_iterator","text":"get_column_iterator(opr, icol)\n\nReturns an iterator which generates a list of elements of the column icol. Each element is represented as (irow, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_element-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer,Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_element","text":"get_element(opr, irow, icol)\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_quantum_number-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.get_quantum_number","text":"get_quantum_number(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_quantum_number with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_quantum_number-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},BR}} where BR where QN","page":"API","title":"ExactDiagonalization.get_quantum_number","text":"get_quantum_number\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_quantum_number-Union{Tuple{QN}, Tuple{Site{QN},Integer}} where QN","page":"API","title":"ExactDiagonalization.get_quantum_number","text":"get_quantum_number(site, state_index)\n\nGets the quantum number of state specified by state_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{BR}, Tuple{NullOperator,BR}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(op, br)\n\nReturns an iterator over the elements of the row corresponding to bit representation br.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{BR}, Tuple{S}, Tuple{O}, Tuple{RHSR}, Tuple{ReducedOperatorRepresentation{RHSR,O,S,BR},Integer}} where BR where S where O where RHSR","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(ropr::ROR, irow_r::Integer)\n\nGet the row iterator for the reduced operator representation\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(opr, irow)\n\nReturns an iterator which generates a list of elements of the row irow. Each element is represented as (icol, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.get_state","text":"get_state(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_state with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_state","text":"get_state(hs, binrep, isite)\n\nGet the local state at site isite for the basis state represented by binrep. Returns an object of type State\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state-Union{Tuple{U}, Tuple{Site,U}} where U<:Unsigned","page":"API","title":"ExactDiagonalization.get_state","text":"get_state(site, binrep) where {QN, BR<:Unsigned}\n\nReturns the state of site represented by the bits binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state_index-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.get_state_index","text":"get_state_index(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_state_index with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state_index-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_state_index","text":"get_state_index(hs, binrep, isite)\n\nGet the index of the local state at site isite for the basis state represented by binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state_index-Union{Tuple{U}, Tuple{Site,U}} where U<:Unsigned","page":"API","title":"ExactDiagonalization.get_state_index","text":"get_state_index(site, binrep)\n\nGets the state index of the binary representation. Returns Int(binrep+1).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.hs_get_basis_list-Union{Tuple{HilbertSpaceSector{HS,QN}}, Tuple{BR}, Tuple{QN}, Tuple{HS}, Tuple{HilbertSpaceSector{HS,QN},Type{BR}}} where BR<:Unsigned where QN where HS","page":"API","title":"ExactDiagonalization.hs_get_basis_list","text":"hs_get_basis_list(hss, binary_type=UInt)\n\nGenerate a basis for the HilbertSpaceSector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.pure_operator-Union{Tuple{BR}, Tuple{S}, Tuple{HilbertSpace,Integer,Integer,Integer}, Tuple{HilbertSpace,Integer,Integer,Integer,S}, Tuple{HilbertSpace,Integer,Integer,Integer,S,Type{BR}}} where BR<:Unsigned where S<:Number","page":"API","title":"ExactDiagonalization.pure_operator","text":"pure_operator(hilbert_space, isite, istate_row, istate_col, amplitude=1, binary_type=UInt)\n\nCreates a pure operator where projection is at one of the sites.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{HilbertSpaceSector{HS,QN}}}, Tuple{QN}, Tuple{HS}} where QN where HS","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(arg::Type{HilbertSpaceSector{QN}})\n\nReturns the quantum number type of the given hilbert space sector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{HilbertSpace{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(::Type{HilbertSpace{QN}})\n\nReturns the quantum number type of the given hilbert space type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{Site{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(::Type{Site{QN}})\n\nReturns the quantum number type of the given site type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{State{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(::Type{State{QN}})\n\nReturns the quantum number type of the given state type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.quantum_number_sectors-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.quantum_number_sectors","text":"quantum_number_sectors(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall quantum_number_sectors with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.quantum_number_sectors-Union{Tuple{HilbertSpace{QN}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.quantum_number_sectors","text":"quantum_number_sectors\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.quantum_number_sectors-Union{Tuple{Site{QN}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.quantum_number_sectors","text":"quantum_number_sectors(site) -> Vector{QN}\n\nGets a list of possible quantum numbers as a sorted vector of QN.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent","text":"represent(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace. This function defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent-Union{Tuple{BR}, Tuple{AbstractHilbertSpace,AbstractArray{BR,1}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent","text":"represent(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors. This defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent-Union{Tuple{O}, Tuple{HSR}, Tuple{HSR,O}} where O<:AbstractOperator where HSR<:HilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.represent","text":"represent(hilbert_space_representation, operator)\n\nCreate an OperatorRepresentation of the operator in the hilbert_space_representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_array-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_array-Union{Tuple{BR}, Tuple{AbstractHilbertSpace,AbstractArray{BR,1}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_dict-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict{binary_type, Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_dict-Union{Tuple{BR}, Tuple{AbstractHilbertSpace,AbstractArray{BR,1}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Tuple{Type{var\"#s23\"} where var\"#s23\"<:HilbertSpace}","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(::Type{HilbertSpace{QN}})\n\nReturns the scalar type of the given hilbert space type. For HilbertSpace{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{SparseState{Scalar,BR}}, Tuple{BR}, Tuple{Scalar}} where BR where Scalar","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype([state or type of state])\n\nReturn the scalar type of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{Type{HilbertSpaceSector{HS,QN}}}, Tuple{QN}, Tuple{HS}} where QN where HS","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(arg::Type{HilbertSpaceSector{HS, QN}})\n\nReturns the scalar type of the given hilbert space sector type. For HilbertSpaceSector{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{Type{var\"#s23\"} where var\"#s23\"<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the scalar type of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.simplify-Tuple{NullOperator}","page":"API","title":"ExactDiagonalization.simplify","text":"simplify\n\nSimplify the given operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.splitblock-Tuple{Integer,Integer}","page":"API","title":"ExactDiagonalization.splitblock","text":"splitblock\n\nSplit n into b blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.splitrange-Tuple{AbstractArray{var\"#s22\",1} where var\"#s22\"<:Integer,Integer}","page":"API","title":"ExactDiagonalization.splitrange","text":"splitrange\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce!-Union{Tuple{So}, Tuple{Si}, Tuple{C}, Tuple{BR}, Tuple{HSR}, Tuple{AbstractArray{So,1},ReducedHilbertSpaceRepresentation{HSR,BR,C},AbstractArray{Si,1}}} where So<:Number where Si<:Number where C where BR where HSR","page":"API","title":"ExactDiagonalization.symmetry_reduce!","text":"symmetry_reduce!(out, rhsr, largevector)\n\nAdds and not overwrites.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.AbstractSymmetryIrrepComponent}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.AbstractSymmetryIrrepComponent,Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce","text":"symmetry_reduce(hsr, lattice, symmetry_irrep_component, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce-Union{Tuple{Si}, Tuple{C}, Tuple{BR}, Tuple{HSR}, Tuple{ReducedHilbertSpaceRepresentation{HSR,BR,C},AbstractArray{Si,1}}} where Si<:Number where C where BR where HSR","page":"API","title":"ExactDiagonalization.symmetry_reduce","text":"symmetry_reduce(rhsr, large_vector)\n\nReduce a large vector into the reduced hilbert space representation. Simply throw away components that don't fit.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_parallel-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.PointSymmetry}}}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.PointSymmetry}},Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_parallel","text":"symmetry_reduce_parallel(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (multi-threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_parallel-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.TranslationSymmetry}}}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.TranslationSymmetry}},Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_parallel","text":"symmetry_reduce_parallel(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (multi-threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_parallel-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.SymmorphicIrrepComponent{var\"#s23\",var\"#s22\"} where var\"#s22\"<:(LatticeTools.SymmetryEmbedding{var\"#s14\"} where var\"#s14\"<:LatticeTools.PointSymmetry) where var\"#s23\"<:(LatticeTools.SymmetryEmbedding{var\"#s17\"} where var\"#s17\"<:LatticeTools.TranslationSymmetry)}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.SymmorphicIrrepComponent{var\"#s13\",var\"#s729\"} where var\"#s729\"<:(LatticeTools.SymmetryEmbedding{var\"#s731\"} where var\"#s731\"<:LatticeTools.PointSymmetry) where var\"#s13\"<:(LatticeTools.SymmetryEmbedding{var\"#s730\"} where var\"#s730\"<:LatticeTools.TranslationSymmetry),Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_parallel","text":"symmetry_reduce_parallel(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (multi-threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_parallel-Union{Tuple{ScalarType}, Tuple{OperationType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},AbstractArray{Tuple{OperationType,ScalarType},N} where N}} where ScalarType<:Number where OperationType<:LatticeTools.AbstractSymmetryOperation where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_parallel","text":"symmetry_reduce_parallel(hsr, symops_and_amplitudes; tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (multi-threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_serial-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.PointSymmetry}}}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.PointSymmetry}},Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_serial","text":"symmetry_reduce_serial(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (single threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_serial-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.TranslationSymmetry}}}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.IrrepComponent{LatticeTools.SymmetryEmbedding{LatticeTools.TranslationSymmetry}},Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_serial","text":"symmetry_reduce_serial(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (single threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_serial-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.SymmorphicIrrepComponent{var\"#s554\",var\"#s555\"} where var\"#s555\"<:(LatticeTools.SymmetryEmbedding{var\"#s557\"} where var\"#s557\"<:LatticeTools.PointSymmetry) where var\"#s554\"<:(LatticeTools.SymmetryEmbedding{var\"#s556\"} where var\"#s556\"<:LatticeTools.TranslationSymmetry)}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},LatticeTools.SymmorphicIrrepComponent{var\"#s558\",var\"#s559\"} where var\"#s559\"<:(LatticeTools.SymmetryEmbedding{var\"#s561\"} where var\"#s561\"<:LatticeTools.PointSymmetry) where var\"#s558\"<:(LatticeTools.SymmetryEmbedding{var\"#s560\"} where var\"#s560\"<:LatticeTools.TranslationSymmetry),Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_serial","text":"symmetry_reduce_serial(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=√ϵ)\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (single threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_serial-Union{Tuple{ScalarType}, Tuple{OperationType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},AbstractArray{Tuple{OperationType,ScalarType},N} where N}} where ScalarType<:Number where OperationType<:LatticeTools.AbstractSymmetryOperation where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_serial","text":"symmetry_reduce_serial\n\nThe irreps have to follow certain order:\n\nsymmetry_reduce_serial(\n    hilbert_space_representation,\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.update-Tuple{HilbertSpaceSector,Vararg{Any,N} where N}","page":"API","title":"ExactDiagonalization.update","text":"update(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall update with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.update-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.update","text":"update(hs, binrep, isite, new_state_index)\n\nUpdate the binary representation of a basis state by changing the state at site isite to a new local state specified by new_state_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{HilbertSpaceRepresentation}","page":"API","title":"LatticeTools.dimension","text":"dimension\n\nDimension of the Concrete Hilbert space, i.e. number of basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{ReducedHilbertSpaceRepresentation}","page":"API","title":"LatticeTools.dimension","text":"dimension(arg::ReducedHilbertSpaceRepresentation{HSR, BR, C}) -> Int\n\nDimension of the given reduced hilbert space representation, i.e. number of basis elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{Site}","page":"API","title":"LatticeTools.dimension","text":"dimension(site)\n\nHilbert space dimension of a given site (= number of states).\n\n\n\n\n\n","category":"method"},{"location":"hilbertspace/#Hilbert-space","page":"Hilbert space","title":"Hilbert space","text":"","category":"section"},{"location":"hilbertspace/#Site","page":"Hilbert space","title":"Site","text":"","category":"section"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"The definition of a quantum many-body problem starts by defining the Hilbert space. The Site serves as a unit Hilbert space, and the Hilbert space for whole system can be constructed by taking the tensor product of them.","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"A Site can be constructed out of a set of State. For example,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"julia> spinsite = Site([State(\"Up\", 1), State(\"Dn\", -1)])\nSite{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"constructs a two-state site with spin-half degrees of freedom. The type parameter Tuple{Int} represents the type of Abelian quantum number. which is is 2S_z in this case. When there are more than one conserved quantum numbers, they can be combined: e.g. Tuple{Int, Int}, to represent the charge and total S_z, for example. Each basis vector is represented as a binary number, corresponding to their order in the constructor (0-based). For the example above, the up-state is represented as 0 and the down-state is represented as 1.","category":"page"},{"location":"hilbertspace/#HilbertSpace","page":"Hilbert space","title":"HilbertSpace","text":"","category":"section"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"We can combine multiple sites to form a HilbertSpace. To construct a Hilbert space from the spin-half sites as defined above,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space = HilbertSpace([spinsite, spinsite, spinsite, spinsite])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"Note that all the basis vectors of the Hilbert space will be represented as a binary number, where each Site occupies a fixed location and width. e.g.","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"|↑↑↑↑⟩ = |0000⟩\n|↑↑↑↓⟩ = |0001⟩\n|↑↑↓↑⟩ = |0010⟩\n       ⋮\n|↓↓↓↓⟩ = |1111⟩","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"The number of bits assigned for each site is determined by Int(ceil(log2(length(site.states))), and can be accessed by bitwidth.","category":"page"},{"location":"hilbertspace/#HilbertSpaceSector","page":"Hilbert space","title":"HilbertSpaceSector","text":"","category":"section"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"A subspace of the whole Hilbert space, in terms of the Abelian quantum number, can be constructed using HilbertSpaceSector, by specifying the value of the quantum number as an integer if the Hilbert space has a single integral quantum number,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, 0)","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"or as a tuple","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, (0,))","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"You can also allow more than one quantum number values, if you need to for whatever reason","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, [(0,), (2,), (4,)])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"or more shortly,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, [0, 2, 4])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"This example creates a subspace whose quantum numbers can be one of 0, 2, and 4.","category":"page"},{"location":"representation/#Representation","page":"Representation","title":"Representation","text":"","category":"section"},{"location":"representation/#HilbertSpaceRepresentation","page":"Representation","title":"HilbertSpaceRepresentation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"A HilbertSpaceRepresentation is a representation of the Hilbert space, with the list of basis vectors in a ascending order of their binary representations, and a lookup table for them. The HilbertSpaceRepresentation can be constructed using represent_array which uses FrozenSortedArrayIndex for the lookup table, or represent_dict which uses Dict.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpace)\nrepresent_array(::HilbertSpace)\nrepresent_dict(::HilbertSpace)","category":"page"},{"location":"representation/#ExactDiagonalization.represent-Tuple{HilbertSpace}","page":"Representation","title":"ExactDiagonalization.represent","text":"represent(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace. This function defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"representation/#ExactDiagonalization.represent_array-Tuple{HilbertSpace}","page":"Representation","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"representation/#ExactDiagonalization.represent_dict-Tuple{HilbertSpace}","page":"Representation","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict{binary_type, Int}.\n\n\n\n\n\n","category":"method"},{"location":"representation/","page":"Representation","title":"Representation","text":"You can also explicitly supply a list of basis vectors","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpace,::Vector{UInt})\nrepresent_array(::HilbertSpace,::Vector{UInt})\nrepresent_dict(::HilbertSpace,::Vector{UInt})","category":"page"},{"location":"representation/#ExactDiagonalization.represent-Tuple{HilbertSpace,Array{UInt64,1}}","page":"Representation","title":"ExactDiagonalization.represent","text":"represent(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors. This defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"representation/#ExactDiagonalization.represent_array-Tuple{HilbertSpace,Array{UInt64,1}}","page":"Representation","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"representation/#ExactDiagonalization.represent_dict-Tuple{HilbertSpace,Array{UInt64,1}}","page":"Representation","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict.\n\n\n\n\n\n","category":"method"},{"location":"representation/#OperatorRepresentation","page":"Representation","title":"OperatorRepresentation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"An OperatorRepresentation is a representation of an operator in the given Hilbert space representation.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpaceRepresentation,::AbstractOperator)","category":"page"},{"location":"representation/#ExactDiagonalization.represent-Tuple{HilbertSpaceRepresentation,AbstractOperator}","page":"Representation","title":"ExactDiagonalization.represent","text":"represent(hilbert_space_representation, operator)\n\nCreate an OperatorRepresentation of the operator in the hilbert_space_representation.\n\n\n\n\n\n","category":"method"},{"location":"symmetry/#Symmetry","page":"Symmetry","title":"Symmetry","text":"","category":"section"},{"location":"symmetry/#ReducedHilbertSpaceRepresentation","page":"Symmetry","title":"ReducedHilbertSpaceRepresentation","text":"","category":"section"},{"location":"symmetry/#ReducedOperatorRepresentation","page":"Symmetry","title":"ReducedOperatorRepresentation","text":"","category":"section"},{"location":"operator/#Operator","page":"Operator","title":"Operator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"ExactDiagonalization.jl uses operators in the \"projector\" representation.","category":"page"},{"location":"operator/#Operator-Types","page":"Operator","title":"Operator Types","text":"","category":"section"},{"location":"operator/#NullOperator","page":"Operator","title":"NullOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A NullOperator, as the name suggests, represents a null operator. It contains no fields, and is thus a singleton.","category":"page"},{"location":"operator/#PureOperator","page":"Operator","title":"PureOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A PureOperator represents an operator of the following form:","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"hatO = alpha hatP_1 otimes hatP_2 otimes ldots otimes hatP_N","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"where alpha is a complex number, and hatP_i is either identity, or projection rᵢcᵢ. It serves as a building block for all the operators used for the construction of the representation of the operators.","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"Internally, PureOperator has fields bitmask, bitrow, bitcol, and amplitude. The bitmask marks whether the hatP_i is identity or projection: If the bitmask for site i is unset, then hatP_i is an identity operator; if it is set, then hatP_i is a projection. The fields bitrow and bitcol can contain information on rᵢ and cᵢ: They can contain nonzero bit-field only at sites with nonzero bitmask.","category":"page"},{"location":"operator/#SumOperator","page":"Operator","title":"SumOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A SumOperator represents a sum of PureOperator. The scalar types of the PureOperators are required to be the same. While a SumOperator can be constructed from the PureOperators, it can also be constructed using additions/subtractions (See Binary Operations).","category":"page"},{"location":"operator/#Mathematical-Operations-for-Operators","page":"Operator","title":"Mathematical Operations for Operators","text":"","category":"section"},{"location":"operator/#Unary-Operations","page":"Operator","title":"Unary Operations","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"Unary operations + and - are defined for the operators. These simply act on the overall amplitude of the operators. + does not do anything and simply returns the original operator, while - changes sign only. The type of the resulting operator, is therefore the same as the original operator. There is one exception: when acting - on an operator whose scalar type is Bool, the resulting type has scalar type Int.","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"In addition to + and -, functions real and imag are also defined for the operators. Depending on the scalar type, the resulting operator has a different type:","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":". N PR PC SR SC\nreal N PR PR SR SR\nimag N N PR N SR","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"N: NullOperator\nPR: PureOperator with real scalar type\nPC: PureOperator with complex scalar type\nSR: SumOperator with real scalar type\nSC: SumOperator with complex scalar type","category":"page"},{"location":"operator/#Binary-Operations","page":"Operator","title":"Binary Operations","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"Binary operations are also defined for the operators. Since PureOperators are closed under multiplication, while product of NullOperator and any operator is always NullOperator, we get the following multiplication table","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"* N P S\nN N N N\nP N P S\nS N S S","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"N: NullOperator, P: PureOperator, S: SumOperator","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"Additions or subtractions of two PureOperators, on the other hand, produce SumOperators","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"+/- N P S\nN N P S\nP P S S\nS S S S","category":"page"},{"location":"links/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"examples/spinhalf/#Example-1:-S1/2-Heisenberg-Chain","page":"Example 1: S=1/2 Heisenberg Chain","title":"Example 1: S=1/2 Heisenberg Chain","text":"","category":"section"},{"location":"examples/spinhalf/","page":"Example 1: S=1/2 Heisenberg Chain","title":"Example 1: S=1/2 Heisenberg Chain","text":"using SparseArrays\nusing LinearAlgebra\nusing Arpack\nusing Plots\n\nusing LatticeTools\nusing ExactDiagonalization\n\nprintln(\"# S=1/2 Heisenberg Chain\")\nn_sites = 8;\n(hs, σ) = ExactDiagonalization.Toolkit.spin_half_system(n_sites)\nprintln(\"Quantum number sectors (2Sz) : \", quantum_number_sectors(hs))\n\nS = Dict(μ => sum(σ(i, μ) for i in 1:n_sites) for μ in [:x, :y, :z])\nspin_squared = simplify(S[:x]^2 + S[:y]^2 + S[:z]^2)\nj1 = simplify(sum(σ(i, j) * σ(mod(i, n_sites)+1 , j) for i in 1:n_sites for j in [:x, :y, :z]))\nhs_rep = represent(hs);     # Use FrozenSortedArrayIndex{UInt} for basis lookup\n\nprintln(\"## All sectors at once\")\nplt = plot(size=(400, 400))\nbegin\n  j1_rep = represent(hs_rep, j1)\n  eigenvalues, eigenvectors = eigs(j1_rep; nev=32, which=:SR, )\n  eigenvalues = real.(eigenvalues)\n  println(\"E : \", eigenvalues[1:5])\n  scatter!(plt,\n           zeros(size(eigenvalues)), eigenvalues,\n           markershape=:hline,\n           markersize=10,\n           markerstrokecolor=:red,\n           legend=:none)\nend\n\nprintln(\"## Sz=0, each momentum sectors\")\nhs_sector = HilbertSpaceSector(hs, 0)\nhs_rep = represent_dict(hs_sector) # Use Dict{UInt, Int} for basis lookup\n\nunitcell = make_unitcell(1.0; SiteType=String)\naddsite!(unitcell, \"Spin\", FractCoord([0], [0.0]))\nlattice = make_lattice(unitcell, 8)\ntsymbed = translation_symmetry_embedding(lattice)\n\n#translation_group = TranslationGroup([Permutation([ mod(i, n_sites)+1 for i in 1:n_sites])])\nks = symmetry(tsymbed).fractional_momenta\n\nfor tsic in get_irrep_components(tsymbed)\n  k = ks[tsic.irrep_index]\n  hs_redrep = symmetry_reduce(hs_rep, tsic)\n  j1_redrep = represent(hs_redrep, j1)\n  j1_redrep_dense = Matrix(j1_redrep)   # Make a dense matrix\n  eigenvalues = eigvals(Hermitian(j1_redrep_dense))\n  println(\"E(k=\", join(string.(k), \",\"), \") : \", eigenvalues[1:5])\n  scatter!(plt,\n           ones(size(eigenvalues)).*tsic.irrep_index, eigenvalues,\n           markershape=:hline,\n           markersize=10,\n           markerstrokecolor=:blue,\n           legend=:none)\nend\nxticks!(plt, collect(0:n_sites), [\"All\", string.(1:n_sites)...])\nxlims!(plt, -1, n_sites+1)\nxlabel!(plt, \"Momentum index\")\nylabel!(plt, \"Energy\")\nsavefig(plt, \"spinchain.svg\"); nothing","category":"page"},{"location":"examples/spinhalf/","page":"Example 1: S=1/2 Heisenberg Chain","title":"Example 1: S=1/2 Heisenberg Chain","text":"(Image: )","category":"page"},{"location":"#ExactDiagonalization","page":"Home","title":"ExactDiagonalization","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExactDiagonalization.jl is a tool for constructing quantum many-body Hamiltonians. It uses Abelian quantum numbers as well as translation symmetry to reduce dimensions of the Hilbert space and the corresponding matrix representation of the Hamiltonian.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A schematic for the structure of the package is the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"                State\n                  ↓\n                Site\n                  ↓\n                HilbertSpace → HilbertSpaceSector   Operator\n                  ↓              ↓                    ↓\n                HilbertSpaceRepresentation        → OperatorRepresentation\n                  ↓                                   ↓\nSymmetryGroup → ReducedHilbertSpaceRepresentation → ReducedOperatorRepresentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"The HilbertSpace, HilbertSpaceSector and Operator implement the abstract Hilbert spaces and operators, while the ...Representations implement the representations of the Hilbert spaces as 𝐂ⁿ (or 𝐑ⁿ), and of operators as n×n matrices.","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First you need to create a Hilbert space representation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define States, and Sites\nDefine the HilbertSpace\nIf there are quantum numbers, use them to define HilbertSpaceSector\nDefine HilbertSpaceRepresentation and construct basis set\nIf there is space symmetry, translation or point or both, use that to define ReducedHilbertSpaceRepresentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then you can create operator representation using the Hilbert space representation from above:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define Operators\nCreate OperatorRepresentation or ReducedOperatorRepresentation using HilbertSpaceRepresentation or ReducedHilbertSpaceRepresentation\nDepending on what is more efficient,","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExactDiagonalization.jl is not yet registered on the Julia package registry. You can install it using its URL as","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/kyungminlee/ExactDiagonalization.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since, however, ExactDiagonalization.jl depends on other packages including LatticeTools.jl, it is convenient to add a custom registry. In Julia, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"]registry add https://github.com/kyungminlee/KyungminLeeRegistry.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"After this, you can","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add ExactDiagonalization","category":"page"}]
}
