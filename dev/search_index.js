var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ExactDiagonalization]","category":"page"},{"location":"api/#ExactDiagonalization.AbstractHilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.AbstractHilbertSpaceRepresentation","text":"AbstractHilbertSpaceRepresentation{S}\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.AbstractOperatorRepresentation","page":"API","title":"ExactDiagonalization.AbstractOperatorRepresentation","text":"AbstractOperatorRepresentation{S}\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpace","page":"API","title":"ExactDiagonalization.HilbertSpace","text":"HilbertSpace{QN}\n\nAbstract Hilbert space with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site{Int64}([State{Int64}(\"Up\", +1), State{Int64}(\"Dn\", -1)])\nSite{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)])\n\njulia> hs = HilbertSpace{Int64}([spin_site, spin_site])\nHilbertSpace{Int64}(Site{Int64}[Site{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)]), Site{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)])], [1, 1], [0, 1, 2])\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.HilbertSpaceRepresentation","text":"HilbertSpaceRepresentation{HS, BR, DictType}\n\nFields\n\nhilbert_space :: HS\nbasis_list    :: Vector{BR}\nbasis_lookup  :: DictType\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.HilbertSpaceSector","page":"API","title":"ExactDiagonalization.HilbertSpaceSector","text":"HilbertSpaceSector{QN}\n\nHilbert space sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.NullOperator","page":"API","title":"ExactDiagonalization.NullOperator","text":"NullOperator\n\nA null operator, i.e. 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.OperatorRepresentation","page":"API","title":"ExactDiagonalization.OperatorRepresentation","text":"OperatorRepresentation{HSR, S, O}\n\nOperator representation of given operator of type O.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.PureOperator","page":"API","title":"ExactDiagonalization.PureOperator","text":"PureOperator{Scalar, BR}\n\nRepresents an operator Î± (Pâ‚  Pâ‚‚    Pâ‚™) where Páµ¢ is either identity (when bitmask is set to zero), or projection ráµ¢cáµ¢ (when bitmask is set to one).\n\nSee also: pure_operator\n\nFields\n\nbitmask   :: BR\nbitrow    :: BR\nbitcol    :: BR\namplitude :: Scalar\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.ReducedHilbertSpaceRepresentation","page":"API","title":"ExactDiagonalization.ReducedHilbertSpaceRepresentation","text":"ReducedHilbertSpaceRepresentation{HSR, BR, C}\n\nRepresentation of the symmetry-reduced hilbert space. Currently only supports Translation group (i.e. Abelian group). ```\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.ReducedOperatorRepresentation","page":"API","title":"ExactDiagonalization.ReducedOperatorRepresentation","text":"ReducedOperatorRepresentation{RHSR, O, S, BR}\n\nRepresentation of an operator of type O in the symmetry-reduced hilbert space representation of type RHSR.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.Site","page":"API","title":"ExactDiagonalization.Site","text":"Site{QN}\n\nA site with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> up = State{Int}(\"Up\", 1); dn = State(\"Dn\", -1);\n\njulia> Site([up, dn])\nSite{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)])\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.SparseState","page":"API","title":"ExactDiagonalization.SparseState","text":"struct SparseState{Scalar<:Number, BR}\n\nRepresents a row vector. Free.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.State","page":"API","title":"ExactDiagonalization.State","text":"State{QN}\n\nState with quantum number type QN.\n\nExamples\n\njulia> using ExactDiagonalization, StaticArrays\n\njulia> up = State{Int}(\"Up\", 1)\nState{Int64}(\"Up\", 1)\n\njulia> State(\"Dn\", SVector{2, Int}([-1, 1]))\nState{SArray{Tuple{2},Int64,1,2}}(\"Dn\", [-1, 1])\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.SumOperator","page":"API","title":"ExactDiagonalization.SumOperator","text":"SumOperator{Scalar, BR}\n\nRepresents a sum of pure operators.\n\nMembers\n\nterms::Vector{PureOperator{Scalar,BR}}\n\n\n\n\n\n","category":"type"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{BR}, Tuple{S2}, Tuple{S1}, Tuple{SparseState{S1,BR},NullOperator,SparseState{S2,BR}}} where BR where S2 where S1","page":"API","title":"ExactDiagonalization.apply!","text":"apply!\n\nApply operator to psi and add it to out.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{S2}, Tuple{S1}, Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where O where S where HSR","page":"API","title":"ExactDiagonalization.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! if greater.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! if greater.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_parallel!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_parallel!","text":"apply_parallel!(out, state, opr; range=1:size(opr, 1))\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_parallel!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_parallel!","text":"apply_parallel!(out, opr, state; range=1:size(opr, 2))\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_serial!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractArray{S2,1},AbstractOperatorRepresentation{S}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_serial!","text":"apply_serial!(out, state, opr; range=1:size(opr, 1))\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.apply_serial!-Union{Tuple{S2}, Tuple{S1}, Tuple{S}, Tuple{AbstractArray{S1,1},AbstractOperatorRepresentation{S},AbstractArray{S2,1}}} where S2<:Number where S1<:Number where S","page":"API","title":"ExactDiagonalization.apply_serial!","text":"apply_serial!(out, opr, state; range=1:size(opr, 2))\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.basespace-Tuple{HilbertSpace}","page":"API","title":"ExactDiagonalization.basespace","text":"basespace(hs)\n\nGet the base space of the HilbertSpace hs, which is itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.basespace-Union{Tuple{HilbertSpaceSector{QN}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.basespace","text":"basespace(hss)\n\nGet the base space of the HilbertSpaceSector, which is its parent HilbertSpace (with no quantum number restriction).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.bitwidth-Tuple{HilbertSpace}","page":"API","title":"ExactDiagonalization.bitwidth","text":"Total number of bits\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site{Int64}([State{Int64}(\"Up\", +1), State{Int64}(\"Dn\", -1)])\nSite{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)])\n\njulia> hs = HilbertSpace{Int64}([spin_site, spin_site, spin_site,])\nHilbertSpace{Int64}(Site{Int64}[Site{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)]), Site{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)]), Site{Int64}(State{Int64}[State{Int64}(\"Up\", 1), State{Int64}(\"Dn\", -1)])], [1, 1, 1], [0, 1, 2, 3])\n\njulia> bitwidth(hs)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.bitwidth-Tuple{Site}","page":"API","title":"ExactDiagonalization.bitwidth","text":"bitwidth(site ::Site)\n\nNumber of bits necessary to represent the states of the given site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},CartesianIndex}, Tuple{HilbertSpace{QN},CartesianIndex,Type{BR}}} where BR<:Unsigned where QN","page":"API","title":"ExactDiagonalization.compress","text":"compress(hs, indexarray ::CartesianIndex, binary_type=UInt)\n\nConvert a cartesian index (a of state) to its binary representation\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site{Int64}([State{Int64}(\"Up\", +1), State{Int64}(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace{Int64}([spin_site, spin_site]);\n\njulia> compress(hs, CartesianIndex(2,2))\n0x0000000000000003\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.compress-Union{Tuple{BR}, Tuple{Site,Integer}, Tuple{Site,Integer,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.compress","text":"compress(site, state_index, binary_type=UInt) :: binary_type\n\nGet binary representation of the state specified by state_index. Check bounds 1 <= state_index <= dimension(site), and returns binary representation of state_index-1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.extract-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},BR}} where BR<:Unsigned where QN","page":"API","title":"ExactDiagonalization.extract","text":"Convert binary representation to an array of indices (of states)\n\nExamples\n\njulia> using ExactDiagonalization\n\njulia> spin_site = Site{Int64}([State{Int64}(\"Up\", +1), State{Int64}(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace{Int64}([spin_site, spin_site]);\n\njulia> extract(hs, 0x03)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_column_iterator-Union{Tuple{BR}, Tuple{NullOperator,BR}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_column_iterator","text":"get_column_iterator(op, bc ::BR)\n\nReturns an iterator over the elements of the column corresponding to bit representation bc.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_column_iterator-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_column_iterator","text":"get_column_iterator(opr, icol)\n\nReturns an iterator which generates a list of elements of the column icol. Each element is represented as (irow, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_element-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer,Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_element","text":"get_element(opr, irow, icol)\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_quantum_number-Union{Tuple{BR}, Tuple{QN}, Tuple{HilbertSpace{QN},BR}} where BR where QN","page":"API","title":"ExactDiagonalization.get_quantum_number","text":"get_quantum_number\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_quantum_number-Union{Tuple{QN}, Tuple{Site{QN},Integer}} where QN","page":"API","title":"ExactDiagonalization.get_quantum_number","text":"get_quantum_number(site, state_index)\n\nGets the quantum number of state specified by state_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{BR}, Tuple{NullOperator,BR}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(op, br ::BR)\n\nReturns an iterator over the elements of the row corresponding to bit representation br.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{BR}, Tuple{S}, Tuple{O}, Tuple{RHSR}, Tuple{ReducedOperatorRepresentation{RHSR,O,S,BR},Integer}} where BR where S where O where RHSR","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(ropr ::ROR, irow_r ::Integer)\n\nGet the row iterator for the reduced operator representation\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_row_iterator-Union{Tuple{O}, Tuple{S}, Tuple{HSR}, Tuple{OperatorRepresentation{HSR,S,O},Integer}} where O where S where HSR","page":"API","title":"ExactDiagonalization.get_row_iterator","text":"get_row_iterator(opr, irow)\n\nReturns an iterator which generates a list of elements of the row irow. Each element is represented as (icol, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_state","text":"get_state(hs, binrep, isite)\n\nGet the local state at site isite for the basis state represented by binrep. Returns an object of type State\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state-Union{Tuple{U}, Tuple{Site,U}} where U<:Unsigned","page":"API","title":"ExactDiagonalization.get_state","text":"get_state(site ::Site{QN}, binrep ::BR) where {QN, BR<:Unsigned}\n\nReturns the state of site represented by the bits binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state_index-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.get_state_index","text":"get_state_index(hs, binrep, isite)\n\nGet the index of the local state at site isite for the basis state represented by binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.get_state_index-Union{Tuple{U}, Tuple{Site,U}} where U<:Unsigned","page":"API","title":"ExactDiagonalization.get_state_index","text":"get_state_index(site, binrep)\n\nGets the state index of the binary representation. Returns Int(binrep+1).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.pure_operator-Union{Tuple{BR}, Tuple{S}, Tuple{HilbertSpace,Integer,Integer,Integer}, Tuple{HilbertSpace,Integer,Integer,Integer,S}, Tuple{HilbertSpace,Integer,Integer,Integer,S,Type{BR}}} where BR<:Unsigned where S<:Number","page":"API","title":"ExactDiagonalization.pure_operator","text":"pure_operator\n\nCreates a pure operator where projection is at one of the sites.\n\nArguments\n\nhilbert_space :: HilbertSpace\nisite         :: Integer\nistate_row    :: Integer\nistate_col    :: Integer\namplitude     :: S = 1\nbinary_type   :: Type{BR} = UInt\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{HilbertSpaceSector{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(arg ::Type{HilbertSpaceSector{QN}})\n\nReturns the quantum number type of the given hilbert space sector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{HilbertSpace{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(arg ::Type{HilbertSpace{QN}})\n\nReturns the quantum number type of the given hilbert space type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{Site{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(::Type{Site{QN}})\n\nReturns the quantum number type of the given site type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.qntype-Union{Tuple{Type{State{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.qntype","text":"qntype(::Type{State{QN}})\n\nReturns the quantum number type of the given state type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.quantum_number_sectors-Union{Tuple{HilbertSpace{QN}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.quantum_number_sectors","text":"quantum_number_sectors\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.quantum_number_sectors-Union{Tuple{Site{QN}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.quantum_number_sectors","text":"quantum_number_sectors(site :: Site{QN}) :: Vector{QN}\n\nGets a list of possible quantum numbers as a sorted vector of QN.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_array-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpaceSector using FrozenSortedArrayIndex{BR}.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_array-Union{Tuple{BR}, Tuple{AbstractHilbertSpace,AbstractArray{BR,1}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_array","text":"represent_array(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict{BR, Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_dict-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace,Type{BR}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.represent_dict-Union{Tuple{BR}, Tuple{AbstractHilbertSpace,AbstractArray{BR,1}}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.represent_dict","text":"represent_dict(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{Type{#s15} where #s15<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the scalar type of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{Type{HilbertSpaceSector{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(arg ::Type{HilbertSpaceSector{QN}})\n\nReturns the scalar type of the given hilbert space sector type. For HilbertSpaceSector{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.scalartype-Union{Tuple{Type{HilbertSpace{QN}}}, Tuple{QN}} where QN","page":"API","title":"ExactDiagonalization.scalartype","text":"scalartype(arg ::Type{HilbertSpace{QN}})\n\nReturns the scalar type of the given hilbert space type. For HilbertSpace{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.simplify-Tuple{NullOperator}","page":"API","title":"ExactDiagonalization.simplify","text":"simplify\n\nSimplify the given operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s31,1} where #s31<:Rational}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s30,1} where #s30<:Rational,Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce","text":"symmetry_reduce(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=sqrt(eps(Float64)))\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce-Union{Tuple{Si}, Tuple{C}, Tuple{BR}, Tuple{HSR}, Tuple{ReducedHilbertSpaceRepresentation{HSR,BR,C},AbstractArray{Si,1}}} where Si<:Number where C where BR where HSR","page":"API","title":"ExactDiagonalization.symmetry_reduce","text":"symmetry_reduce(rhsr, large_vector)\n\nReduce a large vector into the reduced hilbert space representation. Simply throw away components that don't fit.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_parallel-Union{Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s277,1} where #s277<:Rational}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s278,1} where #s278<:Rational,Type{ComplexType}}} where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_parallel","text":"symmetry_reduce_parallel(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=sqrt(eps(Float64)))\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (multi-threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.symmetry_reduce_serial-Union{Tuple{FloatType}, Tuple{ComplexType}, Tuple{DT}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s14,1} where #s14<:Rational}, Tuple{HilbertSpaceRepresentation{QN,BR,DT},TightBindingLattice.TranslationGroup,AbstractArray{#s13,1} where #s13<:Rational,Type{ComplexType}}} where FloatType<:Real where ComplexType<:Complex where DT where BR where QN","page":"API","title":"ExactDiagonalization.symmetry_reduce_serial","text":"symmetry_reduce_serial(hsr, trans_group, frac_momentum, complex_type=ComplexF64, tol=sqrt(eps(Float64)))\n\nSymmetry-reduce the HilbertSpaceRepresentation using translation group (single threaded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.update-Union{Tuple{BR}, Tuple{HilbertSpace,BR,Integer,Integer}} where BR<:Unsigned","page":"API","title":"ExactDiagonalization.update","text":"update(hs, binrep, isite, new_state_index)\n\nUpdate the binary representation of a basis state by changing the state at site isite to a new local state specified by new_state_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#TightBindingLattice.dimension-Tuple{HilbertSpaceRepresentation}","page":"API","title":"TightBindingLattice.dimension","text":"dimension\n\nDimension of the Concrete Hilbert space, i.e. number of basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#TightBindingLattice.dimension-Tuple{Site}","page":"API","title":"TightBindingLattice.dimension","text":"dimension(site ::Site)\n\nHilbert space dimension of a given site (= number of states).\n\n\n\n\n\n","category":"method"},{"location":"api/#TightBindingLattice.dimension-Union{Tuple{ReducedHilbertSpaceRepresentation{HSR,BR,C}}, Tuple{C}, Tuple{BR}, Tuple{HSR}} where C where BR where HSR","page":"API","title":"TightBindingLattice.dimension","text":"dimension(arg ::ReducedHilbertSpaceRepresentation{HSR, BR, C}) -> Int\n\nDimension of the given reduced hilbert space representation, i.e. number of basis elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.valtype-Union{Tuple{Type{#s15} where #s15<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"Base.valtype","text":"valtype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the valtype (scalar type) of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.valtype-Union{Tuple{Type{HilbertSpaceSector{QN}}}, Tuple{QN}} where QN","page":"API","title":"Base.valtype","text":"valtype(arg ::Type{HilbertSpaceSector{QN}})\n\nReturns the valtype (scalar type) of the given hilbert space sector type. For HilbertSpaceSector{QN}, it is always Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.valtype-Union{Tuple{Type{HilbertSpace{QN}}}, Tuple{QN}} where QN","page":"API","title":"Base.valtype","text":"valtype(arg ::Type{HilbertSpace{QN}})\n\nReturns the valtype (scalar type) of the given hilbert space type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.hs_get_basis_list-Union{Tuple{HilbertSpaceSector{QN}}, Tuple{BR}, Tuple{QN}, Tuple{HilbertSpaceSector{QN},Type{BR}}} where BR<:Unsigned where QN","page":"API","title":"ExactDiagonalization.hs_get_basis_list","text":"hs_get_basis_list(hss, binary_type=UInt)\n\nGenerate a basis for the HilbertSpaceSector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExactDiagonalization.splitblock-Tuple{Integer,Integer}","page":"API","title":"ExactDiagonalization.splitblock","text":"splitblock\n\nSplit n into b blocks.\n\n\n\n\n\n","category":"method"},{"location":"hilbertspace/#Hilbert-space-1","page":"Hilbert space","title":"Hilbert space","text":"","category":"section"},{"location":"hilbertspace/#Site-1","page":"Hilbert space","title":"Site","text":"","category":"section"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"The definition of a quantum many-body problem starts by defining the Hilbert space. The Site serves as a unit Hilbert space, and the Hilbert space for whole system can be constructed by taking the tensor product of them.","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"A Site can be constructed out of a set of State. For example,","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"spinsite = Site{Int}([State{Int}(\"Up\", 1), State{Int}(\"Dn\", -1)])","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"constructs a two-state site with spin-half degrees of freedom. The type parameter Int is the type of the Abelian quantum number, which, in this case, is 2S_z. Each basis vector is represented as a (0-based) binary number, corresponding to their order in the constructor. For the example above, the up-state is represented by a 0 and the down-state is represented by a 1.","category":"page"},{"location":"hilbertspace/#HilbertSpace-1","page":"Hilbert space","title":"HilbertSpace","text":"","category":"section"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"We can combine multiple sites to form a HilbertSpace. To construct a Hilbert space from the spin-half sites as defined above,","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space = HilbertSpace([spinsite, spinsite, spinsite, spinsite])","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"Note that all the basis vectors of the Hilbert space will be represented as a binary number, where each Site occupies a fixed location and width. e.g.","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"|â†‘â†‘â†‘â†‘âŸ© = |0000âŸ©\n|â†‘â†‘â†‘â†“âŸ© = |0001âŸ©\n|â†‘â†‘â†“â†‘âŸ© = |0010âŸ©\n       â‹®\n|â†“â†“â†“â†“âŸ© = |1111âŸ©","category":"page"},{"location":"hilbertspace/#HilbertSpaceSector-1","page":"Hilbert space","title":"HilbertSpaceSector","text":"","category":"section"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"A sub Hilbert space, in terms of the Abelian quantum number, can be constructed using HilbertSpaceSector, by specifying the value of the quantum number","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, 0)","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"or a set of quantum number values, if you need to for whatever reason","category":"page"},{"location":"hilbertspace/#","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space_sector = HilbertSpaceSector(hilbert_space, [0,2,4])","category":"page"},{"location":"representation/#Representation-1","page":"Representation","title":"Representation","text":"","category":"section"},{"location":"representation/#AbstractHilbertSpaceRepresentation-1","page":"Representation","title":"AbstractHilbertSpaceRepresentation","text":"","category":"section"},{"location":"representation/#HilbertSpaceRepresentation-1","page":"Representation","title":"HilbertSpaceRepresentation","text":"","category":"section"},{"location":"representation/#AbstractOperatorRepresentation-1","page":"Representation","title":"AbstractOperatorRepresentation","text":"","category":"section"},{"location":"representation/#OperatorRepresentation-1","page":"Representation","title":"OperatorRepresentation","text":"","category":"section"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#S1/2-Heisenberg-Chain-1","page":"Examples","title":"S=1/2 Heisenberg Chain","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using SparseArrays\nusing LinearAlgebra\nusing Arpack\nusing Plots\nusing ExactDiagonalization\nusing TightBindingLattice\n\nprintln(\"# S=1/2 Heisenberg Chain\")\nn_sites = 8;\n(hs, Ïƒ) = ExactDiagonalization.Toolkit.spin_half_system(n_sites)\nprintln(\"Quantum number sectors (2Sz) : \", quantum_number_sectors(hs))\n\nS = Dict(Î¼ => sum(Ïƒ(i, Î¼) for i in 1:n_sites) for Î¼ in [:x, :y, :z])\nspin_squared = simplify(S[:x]^2 + S[:y]^2 + S[:z]^2)\nj1 = simplify(sum(Ïƒ(i, j) * Ïƒ(mod(i, n_sites)+1 , j) for i in 1:n_sites for j in [:x, :y, :z]))\nhs_rep = represent(hs);     # Use FrozenSortedArrayIndex{UInt} for basis lookup\n\nprintln(\"## All sectors at once\")\nplt = plot(size=(300, 400))\nbegin\n  j1_rep = represent(hs_rep, j1)\n  eigenvalues, eigenvectors = eigs(j1_rep; nev=32, which=:SR, )\n  eigenvalues = real.(eigenvalues)\n  println(\"E : \", eigenvalues[1:5])\n  scatter!(plt,\n           zeros(size(eigenvalues)), eigenvalues,\n           markershape=:hline,\n           markersize=10,\n           markerstrokecolor=:red,\n           legend=:none)\nend\n\nprintln(\"## Sz=0, each momentum sectors\")\nhs_sector = HilbertSpaceSector(hs, 0)\nhs_rep = represent_dict(hs_sector) # Use Dict{UInt, Int} for basis lookup\ntranslation_group = TranslationGroup([Permutation([ mod(i, n_sites)+1 for i in 1:n_sites])])\nks = translation_group.fractional_momenta\nfor (ik, k) in enumerate(ks)\n  hs_redrep = symmetry_reduce(hs_rep, translation_group, k)\n  j1_redrep = represent(hs_redrep, j1)\n  #j1_redrep_sparse = sparse(j1_redrep)   # Make a sparse matrix\n  j1_redrep_dense = Matrix(j1_redrep)   # Make a dense matrix\n  eigenvalues = eigvals(Hermitian(j1_redrep_dense))\n  println(\"E(k=\", join(string.(k), \",\"), \") : \", eigenvalues[1:5])\n  scatter!(plt,\n           ones(size(eigenvalues)).*ik, eigenvalues,\n           markershape=:hline,\n           markersize=10,\n           markerstrokecolor=:blue,\n           legend=:none)\nend\nxticks!(plt, collect(0:n_sites), [\"All\", string.(1:n_sites)...])\nxlims!(plt, -1, n_sites+1)\nxlabel!(plt, \"Momentum index\")\nylabel!(plt, \"Energy\")","category":"page"},{"location":"operator/#Operator-1","page":"Operator","title":"Operator","text":"","category":"section"},{"location":"operator/#AbstractOperator-1","page":"Operator","title":"AbstractOperator","text":"","category":"section"},{"location":"operator/#NullOperator-1","page":"Operator","title":"NullOperator","text":"","category":"section"},{"location":"operator/#PureOperator-1","page":"Operator","title":"PureOperator","text":"","category":"section"},{"location":"operator/#SumOperator-1","page":"Operator","title":"SumOperator","text":"","category":"section"},{"location":"links/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/#Types-1","page":"Index","title":"Types","text":"","category":"section"},{"location":"links/#","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links/#Functions-1","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links/#","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"symmetry/#Symmetry-1","page":"Symmetry","title":"Symmetry","text":"","category":"section"},{"location":"symmetry/#ReducedHilbertSpaceRepresentation-1","page":"Symmetry","title":"ReducedHilbertSpaceRepresentation","text":"","category":"section"},{"location":"symmetry/#ReducedOperatorRepresentation-1","page":"Symmetry","title":"ReducedOperatorRepresentation","text":"","category":"section"},{"location":"#ExactDiagonalization-1","page":"Home","title":"ExactDiagonalization","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ExactDiagonalization.jl is a tool for constructing quantum many-body Hamiltonians. It uses Abelian quantum numbers as well as translation symmetry to reduce dimensions of the Hilbert space and the corresponding matrix representation of the Hamiltonian.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A schematic for the structure of the package is the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"                State\n                  â†“\n                Site\n                  â†“\n                HilbertSpace â†’ HilbertSpaceSector   Operator\n                  â†“              â†“                    â†“\n                HilbertSpaceRepresentation        â†’ OperatorRepresentation\n                  â†“                                   â†“\nSymmetryGroup â†’ ReducedHilbertSpaceRepresentation â†’ ReducedOperatorRepresentation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The HilbertSpace, HilbertSpaceSector and Operator implement the abstract Hilbert spaces and operators, while the ...Representations implement the representations of the Hilbert spaces as ð‚â¿ (or ð‘â¿), and of operators as nÃ—n matrices.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ExactDiagonalization.jl is not yet registered on the Julia package registry. You can install it using its URL as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add https://github.com/kyungminlee/ExactDiagonalization.jl.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since, however, ExactDiagonalization.jl depends on other packages including TightBindingLattice.jl, it is convenient to add a custom registry. In shell, type","category":"page"},{"location":"#","page":"Home","title":"Home","text":"$ git clone https://github.com/kyungminlee/KyungminLeeRegistry.jl.git ~/.julia/registries/KyungminLeeRegistry","category":"page"},{"location":"#","page":"Home","title":"Home","text":"on Unix-like systems and Windows PowerShell, or","category":"page"},{"location":"#","page":"Home","title":"Home","text":"> git clone https://github.com/kyungminlee/KyungminLeeRegistry.jl.git %USERPROFILE%\\.julia\\registries\\KyungminLeeRegistry","category":"page"},{"location":"#","page":"Home","title":"Home","text":"on Windows Command Prompt. After this, you can","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add ExactDiagonalization","category":"page"}]
}
